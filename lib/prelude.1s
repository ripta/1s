-- Prelude from a minimal base {CONS, SIP, K}, plus various arithmetic
-- operations as described on http://tunes.org/~iepos/joy.html

-- (1) Binding
-- [BODY*] [NAME] {:} == ø
--
-- {:} is the native implementation of binding a quoted block to a singleton
-- block containing name. It is aliased to :. Bindings consume two quoted
-- blocks from the stack, and has the side-effect that future NAMEs will
-- be evaluated to the unquoted BODY*.
[ {:} ] [ : ] {:}

-- Assert
-- A A {==} == #true
-- B A {==} == #false
--
-- {==} is the native implementation of recursive structural equality.
[ {==} ] [ eq? ] :

-- (2) Cons
-- [REST*] [HEAD_n ... HEAD_1] {CONS} == [[REST*] HEAD_n ... HEAD_1]
--
-- {CONS} is the native implementation of consing, which consumes two quoted
-- blocks from the stack. The second quoted block is appended to the tail
-- of the first quoted block. Both quoted blocks remain unevaluated.
[ {CONS} ] [ cons ] :

-- (3) Sip
-- [B*] [A*] sip == [B*] A [B*]
--
-- {SIP} is a native implementation of the sip combinator, which consumes
-- two quoted blocks from the stack. The second from the top is saved, the
-- top of the stack is evaluated, its, result pushed onto the stack, and then
-- the second from the top is duplicated to the top of the stack.
[ {SIP} ] [ sip keep ] :

-- (4) K / Konstant / Kestrel / Kill
-- [B*] [A*] k == A
--
-- {K} is a native implementation of the K combinator, which consumes two
-- quoted blocks from the stack, evaluates the top, and pushes the evaluation
-- result back onto the stack. The second from the top is discarded without
-- evaluation.
[ {K} ] [ k ] :

-- (5) Dup
-- [A*] dup == [A*] [A*]
--
-- `dup` duplicates the top of the stack without evaluating it. Any literals
-- remain literals, and any quoted blocks remain quoted.
[ [ ] sip ] [ dup ] :

-- (6) I / Identity / Idiot
-- [A*] i == A
--
-- `i` evaluates the quoted block at the top of the stack. Non-quoted blocks
-- cause a runtime error.
[ [ ] sip k ] [ i ] :

-- (7) Unit
-- [A*] unit == [[A*]]
--
-- `unit` quotes the top of the stack. Previously-quoted blocks are doubly-
-- quoted, while previously-literal values are now singly-quoted.
[ [ ] cons ] [ unit quote ] :

-- (8) Zap
-- [A*] zap == ø
--
-- `zap` discards the top of the stack without evaluating it.
[ [ ] k ] [ zap ] :
[ swap zap swap zap ] [ 2zap1 ] :

-- (9) Dip
-- [B*] [A*] dip == A [B*]
--
-- `dip` evaluates the quoted block at the top of the stack,
-- pops the second from the top, pushes the result of the first
-- evaluation, and then pushes the previously second from top.
[ [ [ cons zap ] sip i ] cons sip ] [ dip ] :

-- (10) Catenate
-- [B*] [A*] cat == [B* A*]
--
-- `cat` concatenates the two quoted blocks at the top of the stack
-- into one quoted block.
[ [ [ i ] dip i ] cons cons ] [ cat ] :

-- (11) Swap
-- [B*] [A*] swap == [A*] [B*]
--
-- `swap` swaps the top two of the stack without evaluating them. It
-- is also the base case for `1dig`, `1bury`, and `1flip`, which are
-- all aliases.
[ unit dip ] [ swap 1dig 1bury 1flip ] :

-- (12) Native arithmetic operations on integers and floats
[ {+} ] [ + ] :
[ {-} ] [ - ] :
[ {*} ] [ * ] :
[ {/} ] [ / ] :
[ {%} ] [ % ] :

[ {⌊} ] [ ⌊ ] :
[ {⌊} ] [ ⌋ ] :
[ {⌈} ] [ ⌈ ] :
[ {⌈} ] [ ⌉ ] :

-- (13) syntactic sugar for an empty quoted block
[ [ ] ] [ [] ] :
[ [ [ ] ] ] [ [[]] ] :

-- (14) Digging
-- [C*] [B*] [A*] 2dig == [B*] [A*] [C*]
-- [D*] [C*] [B*] [A*] 3dig == [C*] [B*] [A*] [D*]
-- [E*] [D*] [C*] [B*] [A*] 4dig == [D*] [C*] [B*] [A*] [E*]
--
-- `2dig` reaches under the top two of the stack, and bringing the third
-- to the top. It is the opposite of a 2bury. For convenience, both `3dig`
-- and `4dig` are also provided.
[ [] cons cons dip ] [ 2dig ] :
[ [] cons cons cons dip ] [ 3dig ] :
[ [] cons cons cons cons dip ] [ 4dig ] :

-- (15) Duping
-- [B*] [A*] 2dup == [B*] [A*] [B*] [A*]
--
-- `2dup` duplicates the top two of the stack, preserving the order.
[ swap dup 2dig dup 2dig 2dig ] [ 2dup ] :
[ 2dig dup 2bury 3dig dup 3bury 2dig dup 3bury ] [ 3dup ] :

-- (16) Dig skipping
-- [D*] [C*] [B*] [A*] 2dig1 == [C*] [B*] [D*] [A*]
--
-- `2dig1` performs a 2dig after skipping the top of the stack.
-- Essentially popping the first off, performing a 2dig, and then
-- restoring the top of the stack.
[ [ 2dig ] dip ] [ 2dig1 ] :
[ [ 3dig ] dip ] [ 3dig1 ] :

-- (17) Burying
-- [C*] [B*] [A*] 2bury == [A*] [C*] [B*]
-- [D*] [C*] [B*] [A*] 3bury == [A*] [D*] [C*] [B*]
-- [E*] [D*] [C*] [B*] [A*] 4bury == [A*] [E*] [D*] [C*] [B*]
--
-- `2bury` takes the top of the stack and buries it under the next two
-- of the stack. It is the opposite of 2dig. For convenience, both
-- `3bury` and `4bury` are also provided.
[ [ [] cons cons ] dip swap i ] [ 2bury ] :
[ [ [] cons cons cons ] dip swap i ] [ 3bury ] :
[ [ [] cons cons cons cons ] dip swap i ] [ 4bury ] :

-- (18) Taking
--
-- `take` conses the element to the opposite end of the quoted block.
[ [ dip ] cons cons ] [ take ] :

-- (19) Flipping
-- [C*] [B*] [A*] 3flip == [A*] [B*] [C*]
-- [D*] [C*] [B*] [A*] 4flip == [A*] [B*] [C*] [D*]
--
-- `3flip` flips the top three of the stack, while `4flip` flips the top
-- four of the stack.
[ [] take take take i ] [ 3flip ] :
[ [] take take take take i ] [ 4flip ] :

-- (20) The W, B, and C combinators
-- [B*] [A*] W == [B*] [B*] A
-- [C*] [B*] [A*] B == [[C*] B*] A
-- [C*] [B*] [A*] C == [B*] [C*] A
[ [ dup ] dip i ] [ W ] :
[ [ cons ] dip i ] [ B ] :
[ [ swap ] dip i ] [ C ] :

-- (21) Run combinator
-- [A*] run == A [A*]
--
-- `run` executes the quoted block at the top, and leaves a new copy of
-- the quoted block at the top of the stack, ready for another `run`.
[ dup i swap ] [ run ] :

-- (22) Repeated execution
-- [A*] 0rep == ø
-- [A*] 1rep == A
-- [A*] 2rep == A A
-- [A*] 3rep == A A A
[ zap ] [ 0rep ] :
[ i ] [ 1rep ] :
[ run i ] [ 2rep ] :
[ run run i ] [ 3rep ] :

-- (23) Dup skipping
-- [C*] [B*] [A*] dup2 == [C*] [B*] [A*] [C*]
--
-- `dup2` duplicates the element after skipping the top two. `2dup1` duplicates
-- the two elements after skipping the top one.
[ swap dup 2bury ] [ dup1 over ] :
[ 2dig dup 2dig1 2dig1 ] [ dup2 ] :
[ dup2 dup2 ] [ 2dup1 2over ] :

-- (24) Forking
-- [C*] [B*] [A*] 2fork == AC AB
--
-- `2fork` applies the quotation at the top of the stack to the second and
-- third values consecutively, leaving the results on the stack.
--
-- Example: 5 10 [ 2 + ] 2fork == 7 12
[ dup 2bury i 2bury i swap ] [ 2fork ] :

-- (25) Both
-- C [B*] [A*] both == AC BC
--
-- `both` applies the argument C to both quotations A and B consecutively,
-- leaving the results on the stack. In general, equivalent to:
--
-- C [B*] sip A*
--
-- Example: 5 [ 3 + ] [ 3 * ] both == 8 15
--          5 [ 3 + ] keep 3 *     == 8 15
[ [ keep ] dip i ] [ both ] :

-- (26) Advanced dipping
[ swap [ dip ] dip ] [ 2dip ] :
[ swap [ 2dip ] dip ] [ 3dip ] :

-- (27) Advanced keeping
-- [C*] [B*] [A*] 2keep == [C*] [B*] A [C*] [B*]
-- [D*] [C*] [B*] [A*] 3keep == [D*] [C*] [B*] A [D*] [C*] [B*]
[ [ 2dup ] dip 2dip ] [ 2keep ] :
[ [ 3dup ] dip 3dip ] [ 3keep ] :

-- (28) Car, Cader, and Unconsing
-- [[B*] A*] car == [A*]
-- [[B*] A*] cdr == [B*]
--
-- `car` returns the head of the quoted block at the top of the stack.
-- `cdr` returns the tail of the quoted block at the top of the stack.
-- `uncons` reverses a cons, returning `cdr` and `car` to the top of the stack.
--
-- Example: [ [ 3 ] 2 ] [ 1 ] cons   == [ [ [ 3 ] 2 ] 1 ]
--          [ [ [ 3 ] 2 ] 1 ] car    == [ 1 ]
--          [ [ [ 3 ] 2 ] 1 ] cdr    == [ [ 3 ] 2 ]
--          [ [ [ 3 ] 2 ] 1 ] uncons == [ [ 3 ] 2 ] [ 1 ]
[ {CAR} ] [ car ] :
[ {CDR} ] [ cdr ] :
[ [ cdr ] [ car ] both ] [ uncons ] :

-- (29) Swonsing and Unswonsing
--
-- `swons` is like `cons` with the elements out of order.
[ swap cons ] [ swons ] :
[ uncons swap ] [ unswons ] :

-- (30) Show symbol
[ dup {SHOW} ] [ show ] :

-- (31) Conditionals
-- VALUE [CHECK*] [BRANCH-TRUE*] [BRANCH-FALSE*] if
-- [[BRANCH-n*] [CHECK-n*] ... [BRANCH-2*] [CHECK-2*] [BRANCH-1*] [CHECK-1*]] cond
--
-- `cond` is a native implementation of a series of condition checks. It evaluates
-- the quoted block at the top of the stack. It evaluates the first block (CHECK-#).
-- If the block results in a #true at the top of the stack, then the next block
-- (BRANCH-#) is evaluated, and no other block is evaluated. Execution then
-- continues normally.
--
-- Otherwise, if CHECK-# results in #false, then the next block (BRANCH-#) is skipped,
-- and cond evaluates the next CHECK-# block.
--
-- If all CHECK-# blocks have been exhausted without a match, or if a BRANCH-# block
-- is missing, then an error is thrown.
--
-- `if` is a convenience word built on `cond`, with a limited amount of branching and
-- with a flipped block structure to allow the next element on the stack to be easily
-- used as the CHECK block.
--
-- `if*` is a convenience word built on `if`, where the conditional is preserved when true.
-- C [B*] [A*] if* == C dup [B*] [zap A*] if
--
[ {IF} ] [ if ] :
[ dup2 [ zap i ] [ 2zap1 i ] if ] [ if* ] :
[ [ dup callable? [ zap #true ] [ first i ] if ] find nip
  [ dup callable? [ i ] [ second call ] if ] [ #false "fail" {!!} ] if*
] [ cond ] :

--
-- (END) Ensure stack is empty after evaluation this file to verify that none
-- of the definitions above leave stray words on the stack.
{ø}

-- DO NOT ADD TO END
